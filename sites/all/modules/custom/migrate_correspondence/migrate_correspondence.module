<?php

function migrate_correspondence_migrate_api() {
  $api = array(
    'api' => 2,
    'migrations' => array(
      'EGWCorrespondence' => array(
        'class_name' => 'EGWCorrespondenceMigration',
      ),
    ),
  );
  return $api;
}

class EGWCorrespondenceMigration extends Migration {

  public function __construct() {
    parent::__construct();

    // Source
    //$correspondence = drupal_get_path('module', 'migrate_correspondence') . '/correspondence.csv';
    //$this->source = new MigrateSourceCSV($correspondence, array(), array('header_rows' => 1, 'delimiter' => ';', 'enclosure' => '"'));	
	
	
    $other_database = array(
      'database' => 'archive_library',
      'username' => 'archive_library',
      'password' => 'jkqeq23ffa3rh',
      'host' => 'sql-3',
      'driver' => 'mysql',
    );
    Database::addConnectionInfo('ImportDatabaseKey', 'default', $other_database);
	
	
    $query = db_select('egw_correspondence', 'e')
	  ->fields('e', array('id', 'Collection', 'tTo', 'Number', 'Date', 'Location', 'Published', 'Title', 'tFrom', 'Notes', 'FileLocation'));
	$this->source = new MigrateSourceSQL($query, array(), NULL, array('map_joinable' => TRUE));
	

    // Destination
    $this->destination = new MigrateDestinationNode('correspondence');

    // Mapping
    $this->map = new MigrateSQLMap($this->machineName, array(
      'id' => array(
        'type' => 'int',        
        'not null' => TRUE,
      )
            ), MigrateDestinationNode::getKeySchema()
    );
    
    $this->addFieldMapping('title', 'title_corrected');
    $this->addFieldMapping('field_correspondence_to', 'tTo');
    $this->addFieldMapping('field_correspondence_number', 'Number');
    $this->addFieldMapping('field_correspondence_location', 'Location');
    $this->addFieldMapping('field_correspondence_published', 'Published');
    $this->addFieldMapping('field_corresponcence_title', 'Title');
    $this->addFieldMapping('field_correspondence_from', 'tFrom');
    $this->addFieldMapping('field_correspondence_notes', 'Notes');
    $this->addFieldMapping('field_correspondence_file_loc', 'FileLocation');
    $this->addFieldMapping('field_correspondence_collection', 'collection_corrected');
  }

  public function prepareRow($row) {
  
	/*
	foreach($row as $k => $v) {
		$new_key = substr($k, 1);
		echo $new_key . '|';
		//$row->$new_key = $v;
	}
	*/
  
    if (empty($row->tTo) AND empty($row->Number) AND empty($row->Location) AND empty($row->Pubilshed)) {
      return false;
    }

    // Collection
    $collection = $row->Collection;
    switch ($collection) {
      case 'EGW Letter Index':
        $tcol = 'egw_letters';
        break;
      case 'EGW Manuscripts File':
        $tcol = 'egw_manuscripts';
        break;
      case 'EGW Letters Received':
        $tcol = 'egw_letters_received';
        break;
      case 'W.C. White Letter File':
        $tcol = 'wcwhite_letters';
        break;
    }
    $row->collection_corrected = $tcol;

    // Title
    $title = '';
    if ($row->Title) {
      if ($row->Collection == 'EGW Manuscript File') {
        $title = 'Manuscript: ';
      }
      $title .= $row->Title;
    } else if ($row->Collection == 'EGW Letter Index') {
      $title = 'Letter';
      if ($row->tTo) {
        $title .= ' to ' . $row->tTo;
      }
    } else if ($row->Collection == 'EGW Letters Received') {
      $title = 'Letter';
      if ($row->tFrom) {
        $title .= ' from ' . $row->tFrom;
      }
    } else if ($row->Collection == 'W.C. White Letter File') {
      $title = 'W.C. White Letter';
      if ($row->tTo) {
        $title .= ' to ' . $row->tTo;
      }
    }
    if ($row->Date) {
      list($start_year, $start_month, $start_day) = $this->correctDate($row->Date);
      $dates = array();
      if ($start_year > 0) {
        $dates[] = $start_year;
        if ($start_month > 0) {
          $dates[] = $start_month;
          if ($start_day > 0) {
            $dates[] = $start_day;
          }
        }
      }
      $title .= ' (' . implode('-', $dates) . ')';
    }
    $row->title_corrected = $title;
  }

  public function prepare($node, $row) {
    $this->set_datefield_value('field_correspondence_date', $node, $row->Date);
  }

  public function set_datefield_value($field_name, $node, $date) {

    $approximation = 0;

    if (!empty($date)) {

      list($start_year, $start_month, $start_day) = $this->correctDate($date);

      if ($start_year != false) {

        $rounding = 1;
        if (preg_match('/[1-9]/', $start_month)) {
          $rounding++;
          if (preg_match('/[1-9]/', $start_day)) {
            $rounding++;
          } else {
            if (preg_match('/\?/', $start_day)) {
              $approximation = 1;
            }
            $start_day = '01';
          }
        } else {
          if (preg_match('/\?/', $start_month)) {
            $approximation = 1;
          }
          $start_month = '01';
          $start_day = '01';
        }

        switch ($rounding) {
          case 1:
            $end_year = $start_year;
            $end_month = '12';
            $end_day = '31';
            $rounding2 = 1;
            break;
          case 2:
            $end_year = $start_year;
            $end_month = $start_month;
            $end_day = cal_days_in_month(CAL_GREGORIAN, $end_month, $end_year);
            $rounding2 = 2;
            break;
          case 3:
            $rounding2 = 3;
            $end_year = $start_year;
            $end_month = $start_month;
            $end_day = $start_day;
        }

		//dpr($start_year . '-' . $start_month . '-' . $start_day . ' 00:00:00' . '|');
        if (checkdate((int) $start_month, (int) $start_day, (int) $start_year)) {
          $node->{$field_name}['und'][0]['value'] = $start_year . '-' . $start_month . '-' . $start_day . ' 00:00:00';
          $node->{$field_name}['und'][0]['timezone'] = date_default_timezone();
          $node->{$field_name}['und'][0]['timezone_db'] = 'UTC';
          $node->{$field_name}['und'][0]['rounding'] = $rounding;
          $node->{$field_name}['und'][0]['rounding2'] = $rounding2;
          $node->{$field_name}['und'][0]['value2'] = $end_year . '-' . $end_month . '-' . $end_day . ' 00:00:00';
          $node->{$field_name}['und'][0]['notice'] = $approximation;
          $node->{$field_name}['und'][0]['show_end_date'] = 1;
        }
      }
    }
  }

//  public function prepareKey($source_key, $row) {
//
//    $tkey = md5($row->Collection . $row->Date . $row->Number);
//    $row->id = $tkey;
//    return array(
//      'id' => $tkey
//    );
//  }

  public function correctDate($date) {
    if (strpos($date, 'c')) {
      $approximation = 1;
      $date = preg_replace('/c/', '', $date);
    }

    $tdate = preg_split('/\/|\.|-/', $date);
    if (count($tdate) < 3) {
      preg_match('/[^\/\.-]{4}/', $date, $m);
      $date = str_replace($m[0], substr($m[0], 0, 2) . '.' . substr($m[0], 2), $date);
    } else if (preg_match('/\d{3}\/\d$/', $date, $m)) {
      $num = str_replace('/', '', $m[0]);
      $date = str_replace($m[0], substr($num, 0, 2) . '.' . substr($num, 2), $date);
    }
    list($start_year, $start_month, $start_day) = preg_split('/\/|\.|-/', $date);

    if ($start_year == '??') {
      return array(false, false, false);
    }

    if ($start_year < 25) {
      $start_year = '19' . $start_year;
    } else {
      $start_year = '18' . $start_year;
    }
    if (strlen($start_day) == 4) {
      $start_day = substr($start_day, 2);
    }

    return array($start_year, $start_month, $start_day);
  }

}