<?PHP

/**
 * Implements hook_entity_info().
 * We create new entity to provide searching for files attached by book_field module.
 */
function book_field_search_entity_info() {
    $return = array(
        'lib_book' => array(
            'label' => t('Book for libsys'),
            'description' => t('An entity type used by book_field_search module to provide search for custom fielf book_field.'),
            'base table' => 'lib_book',
            'entity keys' => array(
                'id' => 'lib_book_id',
                'bundle' => 'bundle',
                'fid' => 'fid',
            ),
            'bundle keys' => array(
                'bundle' => 'bundle',
            ),
            'module' => 'book_field_search',
            'uri callback' => 'lib_book_uri_callback',
            'bundles' => array(
                'pdf' => array(
                    'label' => t('PDF'),
                )
            ),
        ),
    );

    return $return;
}

function lib_book_uri_callback($entity) {
    //dpm($entity);
    $fid = $entity->fid;
    $file = file_load($fid);    
    return array(
        'path' => $file->uri,
    );
}

/**
 * @file
 *   Indexer for the hook_apachesolr_entity_info_alter entities for the book_field_search module.
 */
function book_field_apachesolr_entity_info_alter(&$entity_info) {
    $entity_info['lib_book']['indexable'] = TRUE;
    $entity_info['lib_book']['status callback'][] = 'book_field_search_status_callback';
    $entity_info['lib_book']['document callback'][] = 'book_field_search_solr_document';
    $entity_info['lib_book']['reindex callback'] = 'book_field_search_solr_reindex';
    $entity_info['lib_book']['index_table'] = 'apachesolr_index_entities_lib_book';
    $entity_info['lib_book']['result callback'] = 'book_field_search_file_result';
}

/**
 * Status callback for the files. Files should never be removed from the table.
 */
function book_field_search_status_callback($entity_id, $entity_type) {
    module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
    $entity = entity_load($entity_type, array($entity_id));

    $file = file_load($entity[$entity_id]->fid);
    if (apachesolr_attachments_allowed_mime($file->filemime) == FALSE) {
        // Set status to 0 and remove from the index
        return FALSE;
    }

    // Check if the entity status is active
    if ($file->status != 1) {
        // Set status to 0 and remove from the index
        return FALSE;
    }
    // Keep status at 1
    return TRUE;
}

/**
 * Reindexing callback for ApacheSolr, for book_field entities.
 */
function book_field_search_solr_reindex() {
    module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
    $indexer_table = apachesolr_get_indexer_table('lib_book');
    $transaction = db_transaction();
    $env_id = apachesolr_default_environment();
    try {
        // Clean the table
        db_delete($indexer_table)
                ->condition('entity_type', 'lib_book')
                ->isNull('body')
                ->execute();
        db_delete('lib_book')
                ->execute();
        $files = _book_field_search_get_all_files();
        // If we do not have files, return success
        if (empty($files)) {
            return TRUE;
        }
        // Loop over all the files and add them to our indexing table
        foreach ($files as $parent_entity_type => $parent_entities) {
            foreach ($parent_entities as $parent_entity_info) {
                // Fake our file class
                $file = new stdClass();
                foreach ($parent_entity_info->extraFields as $key => $value) {
                    if (strpos($key, '_fid')) {
                        $file->fid = $parent_entity_info->extraFields->$key;
                    }
                }
                list ($parent_entity_id) = entity_extract_ids($parent_entity_type, $parent_entity_info);
                if ($file->fid != 0) {
                    book_field_search_add_file_usage($file, $parent_entity_type, $parent_entity_id);
                }
            }
        }
    } catch (Exception $e) {
        $transaction->rollback();
        drupal_set_message($e->getMessage(), 'error');
        watchdog_exception('Apache Solr Attachments', $e);
        return FALSE;
    }
    return TRUE;
}

function book_field_search_add_file_usage(stdClass $stub_file, $parent_entity_type, $parent_entity_id) {
    // Only add this file type if the parent entity type can be indexed.
    // Example : node is mostly indexed but media module is not. So
    // exclude all media entities from being added
    $entity_info = entity_get_info($parent_entity_type);
    if (!empty($entity_info['apachesolr']['indexable'])) {
        // We do have to load the file, because there is no way to get the
        // bundle type, and media adds many bundles, so fixing this here
        $file = file_load($stub_file->fid);
        $indexer_table = apachesolr_get_indexer_table('lib_book');
        // For non-media files there is no such thing as a defined type/bundle
        // Define it here, so we can have a seamless integration between media and
        // non-media
        if (empty($file->type)) {
            $file->type = 'application';
        }
        $lib_book_id = db_insert('lib_book')
                ->fields(array(
                    'bundle' => 'pdf',
                    'fid' => $file->fid,
                ))
                ->execute();
        $result = entity_load('lib_book', array($lib_book_id), array(), TRUE);
        db_merge($indexer_table)
                ->key(array(
                    'entity_type' => 'lib_book',
                    'entity_id' => $lib_book_id,
                    'parent_entity_type' => $parent_entity_type,
                    'parent_entity_id' => $parent_entity_id,
                ))
                ->fields(array(
                    'bundle' => 'pdf',
                    'status' => $file->status,
                    'changed' => REQUEST_TIME,
                ))->execute();
    }
}

/**
 * Fetches all files linked to nodes created by field from the book_field module *
 */
function _book_field_search_get_all_files() {
    $results = array();
    $fields = field_info_field_by_ids();
    foreach ($fields as $field_id => $field_info) {
        if ($field_info['type'] == 'book_field') {
            foreach ($field_info['bundles'] as $entity_type => $bundles) {
                $entity_info = entity_get_info($entity_type);
                // If this entity type is not indexable, ignore this and move on to the
                // next one
                if (empty($entity_info['apachesolr']['indexable'])) {
                    continue;
                }

                $query = new ApachesolrAttachmentsEntityFieldQuery();
                $results_query = $query
                        ->entityCondition('entity_type', $entity_type)
                        ->fieldCondition($field_info['field_name'])
                        // Fetch all file ids related to the entities
                        ->addExtraField($field_info['field_name'], 'fid', 'fid')
                        ->execute();
                $results = array_merge($results, $results_query);
            }
        }
    }
    return $results;
}

/**
 * Builds the file-specific information for a Solr document.
 *
 * @param ApacheSolrDocument $document
 *   The Solr document we are building up.
 * @param stdClass $entity
 *   The entity we are indexing.
 * @param string $entity_type
 *   The type of entity we're dealing with.
 * @see original apachesolr_attachment_solr_document for information
 */
function book_field_search_solr_document(ApacheSolrDocument $document, $lib_book, $entity_type, $env_id) {
    global $base_url;
    module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
    $documents = array();
    $table = apachesolr_get_indexer_table('lib_book');
    $file = file_load($lib_book->fid);
    $text = apachesolr_attachments_get_attachment_text($file);
    // If we don't have extracted text we should stop our process here
    if (empty($text)) {
        return $documents;
    }
    // Get the list of parents that we should index from the indexing table
    $parents = db_select($table, 'aie')
            ->fields('aie')
            ->condition('entity_type', 'lib_book')
            ->condition('entity_id', $lib_book->lib_book_id)
            ->execute();
    foreach ($parents as $parent) {
        // load the parent entity and reset cache
        $parent_entities = entity_load($parent->parent_entity_type, array($parent->parent_entity_id), NULL, TRUE);
        $parent_entity = reset($parent_entities);
        // Skip invalid entities
        if (empty($parent_entity)) {
            continue;
        }

        // Retrieve the parent entity id and bundle
        list($parent_entity_id, $parent_entity_vid, $parent_entity_bundle) = entity_extract_ids($parent->parent_entity_type, $parent_entity);
        $parent_entity_type = $parent->parent_entity_type;
        // Get a clone of the bare minimum document
        $filedocument = clone $document;
        //Get the callback array to add stuff to the document
        $callbacks = apachesolr_entity_get_callback($parent_entity_type, 'document callback');
        if (empty($callbacks)) {
            continue;
        }
        $build_documents = array();
        foreach ($callbacks as $callback) {
            $build_documents = array_merge($build_documents, $callback($filedocument, $parent_entity, $parent_entity_type, $env_id));
        }

        // Take the top document from the stack
        $filedocument = reset($build_documents);

        // Build our separate document and overwrite basic information
        //Check if parent entity is node.
        if ($parent_entity_type == 'node') {
            $parent_entity = node_load($parent_entity_id);
        } else {
            continue;
        }
        $filedocument->id = apachesolr_document_id($lib_book->lib_book_id . '-' . $parent_entity_type . '-' . $parent_entity_id, $entity_type);

        $filedocument->url = $base_url . "/node/" . $parent_entity_id;
        // A path is not a requirement of an entity        

        $filedocument->path = $base_url . "/node/" . $parent_entity_id;
        $filedocument->parent_entity_id = $parent_entity_id;

        // Add extra info to our document
        $filedocument->label = apachesolr_clean_text($parent_entity->title);
        $filedocument->content = apachesolr_clean_text($file->filename) . ' ' . $text;

        $filedocument->ds_created = apachesolr_date_iso($file->timestamp);
        $filedocument->ds_changed = $filedocument->ds_created;

        $filedocument->created = apachesolr_date_iso($file->timestamp);
        $filedocument->changed = $filedocument->created;

        // Add Parent information fields. See http://drupal.org/node/1515822 for explanation
        $parent_entity_info = entity_get_info($parent_entity_type);
        $small_parent_entity = new stdClass();
        $small_parent_entity->entity_type = $parent_entity_type;
        $small_parent_entity->{$parent_entity_info['entity keys']['id']} = $parent_entity_id;
        $small_parent_entity->{$parent_entity_info['entity keys']['bundle']} = $parent_entity_bundle;
        $small_parent_entity->{$parent_entity_info['entity keys']['label']} = $parent_entity->{$parent_entity_info['entity keys']['label']};
        $filedocument->zm_parent_entity = drupal_json_encode($small_parent_entity);
        $filedocument->sm_parent_entity_bundle = $parent_entity_type . "-" . $parent_entity_bundle;
        $filedocument->sm_parent_entity_type = $parent_entity_type;

        //Indexing all needed attached fields to provide facets. 
        $indexed_fields = apachesolr_entity_fields($parent_entity_type);
        foreach ($indexed_fields as $index_key => $nodefields) {
            foreach ($nodefields as $field_info) {
                $field_name = $field_info['field']['field_name'];
                // See if the node has fields that can be indexed                
                if (isset($parent_entity->{$field_name})) {
                    // Got a field.
                    $function = $field_info['indexing_callback'];
                    if ($function && function_exists($function)) {
                        $fields = $function($parent_entity, $field_name, $index_key, $field_info);
                        foreach ($fields as $field) {
                            $filedocument->setMultiValue($field['key'], $field['value']);
                        }
                    }
                }
            }
        }

        // Add Apachesolr Attachments specific fields.
        $filedocument->ss_filemime = $file->filemime;
        $filedocument->ss_filesize = $file->filesize;
        $documents[] = $filedocument;
    }
    return $documents;
}

//Implements altering of resuts to provide proper links to the nodes
function book_field_search_apachesolr_process_results(&$results, DrupalSolrQueryInterface $query) {
    $result_number = count($results);
    if (module_exists('collection_layout')) {
        for ($i = 0; $i < $result_number; $i++) {
            if ($results[$i]['entity_type'] == 'lib_book') {
                $link = $results[$i]['link'];
                $parent_entity_info = $results[$i]['fields']['zm_parent_entity'][0];
                $pattern = '/nid":"\d+/';
                preg_match($pattern, $parent_entity_info, $matches);
                $pattern = '/\d+/';
                preg_match($pattern, $matches[0], $matches);
                if (isset($matches[0])) {
                    $options = array(
                        'query' => array(
                            'nid' => $matches[0],
                            'search' => arg(2),
                        ),
                        'absolute' => TRUE,
                    );
                    $link = url('node-page', $options);
                    $results[$i]['link'] = $link;
                } else {
                    $options = array(
                        'query' => array(
                            'search' => arg(2),
                        ),
                        'absolute' => TRUE,
                    );
                    $link = url('node-page', $options);
                    $results[$i]['link'] = $link;
                }
            }
        }
    } else {
        for ($i = 0; $i < $result_number; $i++) {
            if ($results[$i]['entity_type'] == 'lib_book') {
                $options = array(
                    'query' => array(
                        'search' => arg(2),
                    ),
                );
                $link = url($results[$i]['link'], $options);
                $results[$i]['link'] = $link;
            }
        }
    }
}

//Implements map callback altering for location field facet to make filters by country 
function book_field_search_facetapi_facet_info_alter(array &$facet_info, array $searcher_info) {
    // Change the author index field for Apache Solr searchers indexing node data.
    if ('apachesolr' == $searcher_info['adapter']) {
        $facet_info['im_field_files_location']['map callback'] = 'book_field_search_location_map_callback';
    }
}

//Map callback for location field
function book_field_search_location_map_callback($facets, $options) {
    $map = array();
    $allowed_references = array();
    $adress_fields = array();
    $country_list = country_get_list();
    $fields = field_info_fields();
    foreach ($fields as $index_field => $field) {
        if ($field['type'] == 'addressfield') {
            $adress_fields += array($index_field => $field);
        }
    }
    $field_name = $options['field']['field_name'];
    if (isset($fields[$field_name])) {
        $allowed_references = node_reference_potential_references($fields[$field_name]);
    }
    foreach ($facets as $key) {
        if (isset($allowed_references[$key])) {
            $node = node_load($key);
            foreach ($adress_fields as $adress_field_name => $adress_field) {
                if (isset($node->$adress_field_name)) {
                    $value = field_get_items('node', $node, $adress_field_name);
                    if (isset($value[0]['country'])) {
                        $country_ISO = $value[0]['country'];
                        $country_name = $country_list[$country_ISO];
                        $map[$key]['#markup'] = field_filter_xss($country_name);
                    } else {
                        $map[$key]['#markup'] = field_filter_xss("Country is undefined");
                    }
                } else {
                    $map[$key]['#markup'] = field_filter_xss("Country is undefined");
                }
            }
        } elseif ($key == '_empty_' && $options['facet missing allowed']) {
            // Facet missing.
            $map[$key]['#markup'] = theme('facetapi_facet_missing', array('field_name' => $options['display_name']));
        }
        $map[$key]['#html'] = TRUE;
    }
    return $map;
}