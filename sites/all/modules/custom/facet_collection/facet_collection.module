<?php

/**
 * Implements hook_menu()
 */
function facet_collection_menu() {
    $items['collection'] = array(
        'title' => t('Collection'),
        'type' => MENU_LOCAL_TASK,
        'page callback' => 'facet_collection_page',
        'page arguments' => array(),
        'access arguments' => array('search content'),
    );
    return $items;
}

/**
 * Page callback for collection
 */
function facet_collection_page() {
    $build = array();
    $environment = apachesolr_default_environment();
    $solr = apachesolr_get_solr($environment);
    $params = facet_collection_get_params();
    $base_path = arg(0);
    $results = apachesolr_search_run('apachesolr', $params, '', $base_path, pager_find_page(), $solr);
    $build['search_results'] = array(
        '#theme' => 'search_results',
        '#results' => $results,
        '#module' => 'facet_collection'
    );
    return $build;
}

/**
 * Get all params to make solr query
 */
function facet_collection_get_params() {
    //We use lucene type here because we make specific query that return only documents corresponds to entity type node;
    $params = array();
    $params['q'] = 'entity_type:node';
    $params['defType'] = 'lucene';
    $params['spellcheck'] = FALSE;
    return $params;
}

/*
 * Implements hook_block_info()
 */

function facet_collection_block_info() {
    $blocks['content_types_selection'] = array(
        'info' => t('Filters for nodes')
    );
    return $blocks;
}

/*
 * Implements hook_block_view()
 */

function facet_collection_block_view($delta) {

    //We need to collect all facetapi presentations for separate block in one 
    //and add titles for each facet.
    $realm_name = 'block';
    $content = array();
    if ($delta == 'content_types_selection') {
        //We need searcher for further actions.         
        $searcher_info = facetapi_get_searcher_info();
        $searcher = array_shift(array_keys($searcher_info));

        //Get adapter and build block realm to grab all build information
        $adapter = facetapi_adapter_load($searcher);

        //We should check facets visibility.
        if (!cache_get('facet_collection:visibility')) {
            facet_collection_set_facets_visibility($adapter, $realm_name, $searcher);
        }

        //Get filter settings
        $filter_settings = drupal_json_decode(variable_get('facet_collection_filters_settings'));

        //Get all facets that can be shown because we need only facets that satisfy all chosen content types.  

        $available_facets = facet_collection_get_available_facets($filter_settings);

        //Build content using facetapi block presentation for each facet
        $enabled_facets = $adapter->getEnabledFacets();
        $builds = facetapi_build_realm($searcher, $realm_name);
        foreach ($builds as $facet_name => $build) {
            if (is_array($build) && !empty($available_facets)) {
                if (in_array($facet_name, $available_facets)) {
                    $field_alias = $enabled_facets[$facet_name]['field alias'];
                    $title = $build['#title'];
                    $build[$field_alias]['#title'] = $title;
                    $content[] = $build;
                }
            }
        }
    }

    return array(
        'subject' => t('Filters'),
        'content' => $content,
    );
}

/*
 * Set collection fasets visibility and make record in database
 */

function facet_collection_set_facets_visibility($adapter, $realm_name, $searcher) {
    $realm = facetapi_realm_load($realm_name);
    $data = cache_get('facet_collection:listfacets');
    $facet_list = $data->data;
    foreach ($facet_list as $faset_name) {
        $faset = facetapi_facet_load($faset_name, $searcher);
        facetapi_save_facet_enabled($adapter, $realm, $faset);
    }
    cache_set('facet_collection:visibility', TRUE, 'cache', CACHE_TEMPORARY);
}

/**
 * Filter facet list to show only facets that satisfy all chosen content types
 */
function facet_collection_get_available_facets($filter_settings) {
    $available_facets = array();

    //Get all facets for collection from cache
    $data = cache_get('facet_collection:listfacets');
    $facet_list = $data->data;

    //@todo Get it from settings.
    $content_types = array('files', 'location', 'people');

    //By defaults all content types are shown. If we take content type filters the list of content types will be changed.
    $content_types_by_filters = FALSE;
    if (isset($_GET['f'])) {

        //Check if there are some filters and if it's true check if this filters are content type filters.
        $filters = $_GET['f'];
        foreach ($filters as $filter) {
            $arr = explode(':', $filter);
            if ($arr[0] == 'bundle') {

                //List of content types will consist on all chosen content types.
                if ($content_types_by_filters == FALSE) {
                    $content_types = array();
                }
                $content_types_by_filters = TRUE;
                if ($content_types_by_filters == TRUE) {
                    $content_types[] = $arr[1];
                }
            }
        }
    }

    //Perform comparison with conent type list of each facet. 
    //If it is satisfy all chosen  content types we take this facet     
    $searcher_info = facetapi_get_searcher_info();
    $searcher = array_shift(array_keys($searcher_info));
    foreach ($facet_list as $facet_name) {
        $facet_content_types_array = array();
        if ($facet_name == 'collection_date_facet') {
            continue;
        }
        $facet = facetapi_facet_load($facet_name, $searcher);
        $field_info = field_info_field($facet['field api name']);
        if ($field_info['type'] == 'taxonomy_term_reference') {
            $voc_machine_name = $field_info['settings']['allowed_values'][0]['vocabulary'];
            if (isset($filter_settings['taxonomy_term_reference'][$voc_machine_name])) {
                $facet_content_types_array = array_keys($filter_settings['taxonomy_term_reference'][$voc_machine_name]);
            }
        }
        if ($field_info['type'] == 'node_reference') {
            if (isset($filter_settings['node_reference'][$field_info['field_name']])) {
                $facet_content_types_array = array_keys($filter_settings['node_reference'][$field_info['field_name']]);
            }
        }
        $array_diff = array_diff($content_types, $facet_content_types_array);
        if (empty($array_diff)) {
            $available_facets[] = $facet_name;
        }
    }
    return $available_facets;
}

/**
 * Implements hook_entity_info_alter().
 */
function facet_collection_apachesolr_entity_info_alter(&$entity_info) {
    // Add document callback to provide all needed filters   
    $entity_info['node']['document callback'][] = 'facet_collection_solr_document';
}

/*
 * Document callback for nodes
 */

function facet_collection_solr_document(ApacheSolrDocument $document, $node, $entity_type, $env_id) {
    $filedocument = clone $document;
    $indexed_fields = apachesolr_entity_fields($entity_type);
    foreach ($indexed_fields as $index_key => $nodefields) {
        foreach ($nodefields as $field_info) {
            $field_name = $field_info['field']['field_name'];

            // See if the node has fields that can be indexed                
            if (!empty($node->{$field_name})) {
                //Add our fields in document. 
                if ($field_info['field']['type'] == 'taxonomy_term_reference') {
                    foreach ($field_info['field']['settings']['allowed_values'] as $vocabulary) {
                        $voc_name = $vocabulary['vocabulary'];
                    }
                    $items = field_get_items('node', $node, $field_name);
                    $index_field_name = facet_collection_get_fieldname_by_vocabulary($voc_name);
                    foreach ($items as $item) {
                        $filedocument->setMultiValue($index_field_name, $item['tid']);
                    }
                }
                if ($field_info['field']['type'] == 'node_reference') {
                    foreach ($field_info['field']['settings']['referenceable_types'] as $content_type) {
                        if ($content_type == '0') {
                            continue;
                        }
                        $function = $field_info['indexing_callback'];
                        if ($function && function_exists($function)) {
                            $fields = $function($node, $field_name, $index_key, $field_info);
                            foreach ($fields as $field) {
                                $filedocument->setMultiValue($field['key'], $field['value']);
                            }
                        }
                    }
                }
                if ($field_info['field']['type'] == 'date' || $field_info['field']['type'] == 'datetime') {
                    $fields = facet_collection_date_indexing_callback($node, $field_name, 'dm_facet_collection_date', $field_info);
                    foreach ($fields as $field) {
                        $filedocument->setMultiValue($field['key'], $field['value']);
                    }
                }
            }
        }
    }
    $documents = array();
    $documents[] = $filedocument;

    return $documents;
}

/**
 * Index callback for date fields
 */
function facet_collection_date_indexing_callback($node, $field_name, $index_key, $field_info) {
    //If we have date with certain precision we should add additional dates in document to perform filtration
    $fields = array();
    $field = $node->$field_name;
    list($lang, $values) = each($field);
    foreach ($values as $value) {
        if (isset($value['value2'])) {
            $date_start = new DateObject($value['value']);

            //Comparison of start and end dates     
            $date_end = new DateObject($value['value2']);
            $difference = $date_start->difference($date_end, 'days');
            $date_array = $date_start->toArray();
            $year = $date_array['year'];

            //If difference is equal one year we should add 365 or 366 dates for the field to fill all year date range.
            if ($difference == 365 || $difference == 366) {
                for ($month = 1; $month <= 12; $month++) {
                    $days_in_month = date_days_in_month($year, $month);
                    for ($day_number = 1; $day_number <= $days_in_month; $day_number++) {
                        $date_string = $year . '/' . $month . '/' . $day_number;
                        $date_obj = new DateObject($date_string, NULL, 'Y/m/d');
                        $date_array = $date_obj->toArray(TRUE);
                        $date_ISO = $date_obj->toISO($date_array);
                        $date = date_create($date_ISO);
                        $index_value = apachesolr_date_iso($date->format('U'));
                        $fields[] = array(
                            'key' => $index_key,
                            'value' => $index_value,
                        );
                    }
                }
            } elseif ($difference == 0) {

                //Just add the date to field
                $date = date_create($value['value']);
                $index_value = apachesolr_date_iso($date->format('U'));
                $fields[] = array(
                    'key' => $index_key,
                    'value' => $index_value,
                );

                //Adding dates that fill current month
            } else {
                $month = $date_array['month'];
                $days_in_month = date_days_in_month($year, $month);
                for ($day_number = 1; $day_number <= $days_in_month; $day_number++) {
                    $date_string = $year . '/' . $month . '/' . $day_number;
                    $date_obj = new DateObject($date_string, NULL, 'Y/m/d');
                    $date_array = $date_obj->toArray(TRUE);
                    $date_ISO = $date_obj->toISO($date_array);
                    $date = date_create($date_ISO);
                    $index_value = apachesolr_date_iso($date->format('U'));
                    $fields[] = array(
                        'key' => $index_key,
                        'value' => $index_value,
                    );
                }
            }

            //We store min and max date in persistent variables because we need min and max callbacks for facet
            //that returns this values
            //Check if current date is min or max from all indexed dates  
            $max_date = variable_get('facet_collection_max_indexed_date');
            $min_date = variable_get('facet_collection_min_indexed_date');
            if (!empty($max_date)) {
                $max_date_obj = new DateObject($max_date);
                if ($max_date_obj < $date_end) {
                    $date_array = $date_end->toArray(TRUE);
                    $date_ISO = $date_end->toISO($date_array);
                    variable_set('facet_collection_max_indexed_date', $date_ISO);
                }
            } else {
                $date_array = $date_end->toArray(TRUE);
                $date_ISO = $date_end->toISO($date_array);
                variable_set('facet_collection_max_indexed_date', $date_ISO);
            }
            if (!empty($min_date)) {
                $min_date_obj = new DateObject($min_date);
                if ($date_start < $min_date_obj) {
                    $date_array = $date_start->toArray(TRUE);
                    $date_ISO = $date_start->toISO($date_array);
                    variable_set('facet_collection_min_indexed_date', $date_ISO);
                }
            } else {
                $date_array = $date_start->toArray(TRUE);
                $date_ISO = $date_start->toISO($date_array);
                variable_set('facet_collection_min_indexed_date', $date_ISO);
            }
        }
    }
    return $fields;
}

/**
 * Get unique field name by vocabulary name
 */
function facet_collection_get_fieldname_by_vocabulary($voc_name) {
    return 'im_voc_' . $voc_name;
}

/**
 * Implements hook_facetapi_facet_info()
 */
function facet_collection_facetapi_facet_info($searcher_info) {
    $facets = array();
    $data = array();
    $realm = 'block';
    $indexed_fields = apachesolr_entity_fields('node');
    $instances = field_info_instances('node');
    foreach ($indexed_fields as $index_key => $nodefields) {
        foreach ($nodefields as $field_info) {
            $field_name = $field_info['field']['field_name'];
            $bundle = array_shift($field_info['field']['bundles']['node']);
            $map_callback = $field_info['map callback'];
            $map_options = $field_info;
            $min_callback = FALSE;
            $max_callback = FALSE;
            $query_types = array('term');
            $default_widget = 'facetapi_links';
            if ($field_info['field']['type'] == 'taxonomy_term_reference') {
                $voc_machine_name = $field_info['field']['settings']['allowed_values'][0]['vocabulary'];
                if (empty($voc_machine_name)) {
                    continue;
                }
                $vocabulary = taxonomy_vocabulary_machine_name_load($voc_machine_name);
                $facet_name = 'collection_' . $voc_machine_name;
                $data[] = $facet_name;
                if (isset($facets[$facet_name])) {
                    continue;
                }
                $label = $vocabulary->name;
                $index_field_name = facet_collection_get_fieldname_by_vocabulary($voc_machine_name);
                $map_callback = 'facet_collection_map_taxonomy_terms';
                $map_options = array();
            }
            if ($field_info['field']['type'] == 'node_reference') {
                $facet_name = 'collection_' . $field_name;
                $label = $instances[$bundle][$field_name]['label'];
                $index_field_name = apachesolr_index_key($field_info);
                $data[] = $facet_name;
            }
            if ($field_info['field']['type'] == 'date' || $field_info['field']['type'] == 'datetime') {
                $facet_name = 'collection_date_facet';
                $label = 'Date';
                $index_field_name = 'dm_facet_collection_date';
                $query_types = array('date');
                $default_widget = 'facetapi_date_range_widget';
                $min_callback = 'facet_collection_get_min_date';
                $max_callback = 'facet_collection_get_max_date';
                $data[] = $facet_name;
            }
            $facets[$facet_name] = array(
                'name' => $facet_name,
                'label' => t($label),
                'description' => t('Automatically created facet for facet collection module'),
                'field' => $index_field_name,
                'field alias' => $facet_name,
                'field api name' => $field_name,
                'field api bundles' => array(),
                'query types' => $query_types,
                'default widget' => $default_widget,
                'allowed operators' => array(FACETAPI_OPERATOR_AND => FALSE, FACETAPI_OPERATOR_OR => TRUE),
                'facet mincount allowed' => TRUE,
                'facet missing allowed' => TRUE,
                'map callback' => $map_callback,
                'map options' => $map_options,
                'min callback' => $min_callback,
                'max callback' => $max_callback,
            );
        }
    }   
    cache_set('facet_collection:listfacets', $data, 'cache', CACHE_TEMPORARY);
    return $facets;
}

/**
 * Map callback for taxonomy term facet
 */
function facet_collection_map_taxonomy_terms($variables) {
    $map = array();
    foreach ($variables as $tid) {
        $term = taxonomy_term_load($tid);
        $map[$tid] = entity_label('taxonomy_term', $term);
    }
    return $map;
}

/**
 * Implements hook_form_alter()
 */
function facet_collection_form_alter(&$form, &$form_state, $form_id) {
    if ($form_id == 'apachesolr_index_action_form_delete_confirm') {
        $form['#submit'][] = 'facet_collection_index_action_form_delete_submit';
    }
}

/**
 * Submit callback for apachesolr_index_action_form. We need it to remove persistent variables that contain min and max dates
 */
function facet_collection_index_action_form_delete_submit($form, &$form_state) {
    variable_del('facet_collection_min_indexed_date');
    variable_del('facet_collection_max_indexed_date');
}

/**
 * Max date callback for facet collection
 */
function facet_collection_get_max_date() {
    return strtotime(variable_get('facet_collection_max_indexed_date'));
}

/**
 * Min date callback for facet collection
 */
function facet_collection_get_min_date() {
    return strtotime(variable_get('facet_collection_min_indexed_date'));
}

/**
 * Implements hook_apachesolr_query_alter()
 */
function facet_collection_apachesolr_query_alter($query) {
    $content_types = array('files', 'location', 'people');
    //If filtration by date is used we should get only content types that available for filtration by date
    if (arg(0) == 'collection') {
        $filters = $query->getFilters();
        foreach ($filters as $filter) {
            if ($filter['#name'] == 'dm_facet_collection_date') {
                $filters_settings = variable_get('facet_collection_filters_settings');
                $filters_settings = drupal_json_decode($filters_settings);

                //Get available content types from settings
                $available_content_types = array();
                if (isset($filters_settings['date'])) {
                    $available_content_types = array_merge($available_content_types, array_keys($filters_settings['date']));
                }
                if (isset($filters_settings['datetime'])) {
                    $available_content_types = array_merge($available_content_types, array_keys($filters_settings['datetime']));
                }

                //Get filtering content types for current query
                $filtering_content_types = array();
                if (isset($_GET['f'])) {
                    $f = $_GET['f'];
                    foreach ($f as $key => $row) {
                        if (strstr($row, 'bundle')) {
                            $arr = explode(':', $row);
                            $filtering_content_type = $arr[1];
                            $filtering_content_types[] = $filtering_content_type;
                        }
                    }
                }

                //Exclude all forbidden content types from query and save only allowed content types in filter
                if (!empty($filtering_content_types)) {
                    $forbidden_content_types = array_diff($filtering_content_types, $available_content_types);
                    dpm($forbidden_content_types);
                    $query->removeFilter('bundle');
                    if (!empty($forbidden_content_types)) {
                        $allowed_content_types = array_diff($filtering_content_types, $forbidden_content_types);
                        if (!empty($allowed_content_types)) {
                            $query->addFilter('bundle', '(' . implode(' OR ', $allowed_content_types) . ')', FALSE);
                        } else {
                            $query->addFilter('bundle', '(' . implode(' OR ', $available_content_types) . ')', FALSE);
                        }
                    } else {
                        $query->addFilter('bundle', '(' . implode(' OR ', $filtering_content_types) . ')', FALSE);
                    }
                } else {
                    $query->removeFilter('bundle');
                    $query->addFilter('bundle', '(' . implode(' OR ', $available_content_types) . ')', FALSE);
                }
            }
        }
    }
}