<?php

/**
 * Implements hook_facet_collection_field_type_info()
 */
function facet_collection_date_facet_collection_field_type_info() {
    return array('date', 'datetime', 'datestamp');
}

/**
 * Implements hook_facet_collection_field_facet_groups()
 */
function facet_collection_date_facet_collection_field_facet_groups($field_info) {
    $facets = array();
    $field_name = $field_info['field_name'];
    $facet_name = 'collection_date_facet';
    $label = 'Date';
    $index_field_name = 'dm_facet_collection_date';
    $query_types = array('date');
    $default_widget = 'facetapi_date_range_widget';
    $min_callback = 'facet_collection_get_min_date';
    $max_callback = 'facet_collection_get_max_date';

    $facets[$facet_name] = array(
        'name' => $facet_name,
        'label' => t($label),
        'description' => t('Automatically created facet for facet collection module'),
        'field' => $index_field_name,
        'field alias' => $facet_name,
        'field api name' => $field_name,
        'field api bundles' => array(),
        'query types' => $query_types,
        'default widget' => $default_widget,
        'allowed operators' => array(FACETAPI_OPERATOR_AND => FALSE, FACETAPI_OPERATOR_OR => TRUE),
        'facet mincount allowed' => TRUE,
        'facet missing allowed' => TRUE,
        'map callback' => FALSE,
        'map options' => FALSE,
        'min callback' => $min_callback,
        'max callback' => $max_callback
    );
    $facet_groups['default'] = $facets;
    return $facet_groups;
}

/**
 * Implements hook_facet_collection_index_field()
 */
function facet_collection_date_facet_collection_index_field($filedocument, $node, $field_info) {
    $fields = facet_collection_date_indexing_callback($node, 'dm_facet_collection_date', $field_info);
      foreach ($fields as $field) {
      $filedocument->setMultiValue($field['key'], $field['value']);
    }
    return $filedocument;
}

/**
 * Implements hook_facet_collection_facet_content_types()
 */
function facet_collection_date_facet_collection_facet_content_types($filter_settings, $facet_group, $facet_name, $searcher) {
    $facet_content_types_array = array();
    return $facet_content_types_array;
}

/**
 * Index callback for date fields
 */
function facet_collection_date_indexing_callback($node, $index_key, $field_info) {
    $field_name = $field_info['field_name'];
//If we have date with certain precision we should add additional dates in document to perform filtration
    $fields = array();
    $field = $node->$field_name;
    list($lang, $values) = each($field);
    foreach ($values as $value) {
        if (isset($value['value2'])) {
            $date_start = new DateObject($value['value']);

//Comparison of start and end dates
            $date_end = new DateObject($value['value2']);
            $difference = $date_start->difference($date_end, 'days');
            $date_array = $date_start->toArray();
            $year = $date_array['year'];

//If difference is equal one year we should add 365 or 366 dates for the field to fill all year date range.
            if ($difference == 365 || $difference == 366) {
                for ($month = 1; $month <= 12; $month++) {
                    $days_in_month = date_days_in_month($year, $month);
                    for ($day_number = 1; $day_number <= $days_in_month; $day_number++) {
                        $date_string = $year . '/' . $month . '/' . $day_number;
                        $date_obj = new DateObject($date_string, NULL, 'Y/m/d');
                        $date_array = $date_obj->toArray(TRUE);
                        $date_ISO = $date_obj->toISO($date_array);
                        $date = date_create($date_ISO);
                        $index_value = apachesolr_date_iso($date->format('U'));
                        $fields[] = array(
                            'key' => $index_key,
                            'value' => $index_value,
                        );
                    }
                }
            } elseif ($difference == 0) {

//Just add the date to field
                $date = date_create($value['value']);
                $index_value = apachesolr_date_iso($date->format('U'));
                $fields[] = array(
                    'key' => $index_key,
                    'value' => $index_value,
                );

//Adding dates that fill current month
            } else {
                $month = $date_array['month'];
                $days_in_month = date_days_in_month($year, $month);
                for ($day_number = 1; $day_number <= $days_in_month; $day_number++) {
                    $date_string = $year . '/' . $month . '/' . $day_number;
                    $date_obj = new DateObject($date_string, NULL, 'Y/m/d');
                    $date_array = $date_obj->toArray(TRUE);
                    $date_ISO = $date_obj->toISO($date_array);
                    $date = date_create($date_ISO);
                    $index_value = apachesolr_date_iso($date->format('U'));
                    $fields[] = array(
                        'key' => $index_key,
                        'value' => $index_value,
                    );
                }
            }

//We store min and max date in persistent variables because we need min and max callbacks for facet
//that returns this values
//Check if current date is min or max from all indexed dates
            $max_date = variable_get('facet_collection_max_indexed_date');
            $min_date = variable_get('facet_collection_min_indexed_date');
            if (!empty($max_date)) {
                $max_date_obj = new DateObject($max_date);
                if ($max_date_obj < $date_end) {
                    $date_array = $date_end->toArray(TRUE);
                    $date_ISO = $date_end->toISO($date_array);
                    variable_set('facet_collection_max_indexed_date', $date_ISO);
                }
            } else {
                $date_array = $date_end->toArray(TRUE);
                $date_ISO = $date_end->toISO($date_array);
                variable_set('facet_collection_max_indexed_date', $date_ISO);
            }
            if (!empty($min_date)) {
                $min_date_obj = new DateObject($min_date);
                if ($date_start < $min_date_obj) {
                    $date_array = $date_start->toArray(TRUE);
                    $date_ISO = $date_start->toISO($date_array);
                    variable_set('facet_collection_min_indexed_date', $date_ISO);
                }
            } else {
                $date_array = $date_start->toArray(TRUE);
                $date_ISO = $date_start->toISO($date_array);
                variable_set('facet_collection_min_indexed_date', $date_ISO);
            }
        }
    }
    return $fields;
}

/**
 * Implements hook_apachesolr_query_alter()
 */
function facet_collection_apachesolr_query_alter($query) {
    $content_types = array('files', 'location', 'people');
//If filtration by date is used we should get only content types that available for filtration by date
    if (arg(0) == 'collection') {
        $filters = $query->getFilters();
        foreach ($filters as $filter) {
            if ($filter['#name'] == 'dm_facet_collection_date') {
                $filters_settings = variable_get('facet_collection_filters_settings');
                $filters_settings = drupal_json_decode($filters_settings);

//Get available content types from settings
                $available_content_types = array();
                if (isset($filters_settings['date'])) {
                    $available_content_types = array_merge($available_content_types, array_keys($filters_settings['date']));
                }
                if (isset($filters_settings['datetime'])) {
                    $available_content_types = array_merge($available_content_types, array_keys($filters_settings['datetime']));
                }

//Get filtering content types for current query
                $filtering_content_types = array();
                if (isset($_GET['f'])) {
                    $f = $_GET['f'];
                    foreach ($f as $key => $row) {
                        if (strstr($row, 'bundle')) {
                            $arr = explode(':', $row);
                            $filtering_content_type = $arr[1];
                            $filtering_content_types[] = $filtering_content_type;
                        }
                    }
                }

//Exclude all forbidden content types from query and save only allowed content types in filter
                if (!empty($filtering_content_types)) {
                    $forbidden_content_types = array_diff($filtering_content_types, $available_content_types);
                    $query->removeFilter('bundle');
                    if (!empty($forbidden_content_types)) {
                        $allowed_content_types = array_diff($filtering_content_types, $forbidden_content_types);
                        if (!empty($allowed_content_types)) {
                            $query->addFilter('bundle', '(' . implode(' OR ', $allowed_content_types) . ')', FALSE);
                        } else {
                            $query->addFilter('bundle', '(' . implode(' OR ', $available_content_types) . ')', FALSE);
                        }
                    } else {
                        $query->addFilter('bundle', '(' . implode(' OR ', $filtering_content_types) . ')', FALSE);
                    }
                } else {
                    $query->removeFilter('bundle');
                    $query->addFilter('bundle', '(' . implode(' OR ', $available_content_types) . ')', FALSE);
                }
            }
        }
    }
}